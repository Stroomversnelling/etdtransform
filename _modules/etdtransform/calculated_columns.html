

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>etdtransform.calculated_columns &mdash; etdtransform - &#34;Energietransitie Dataset&#34; transformation and loading package 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=cb975c41"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            etdtransform - "Energietransitie Dataset" transformation and loading package
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../source/modules.html">etdtransform</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">etdtransform - "Energietransitie Dataset" transformation and loading package</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">etdtransform.calculated_columns</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for etdtransform.calculated_columns</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ibis</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>


<div class="viewcode-block" id="add_calculated_columns_imputed_data">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.add_calculated_columns_imputed_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_calculated_columns_imputed_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">fillna</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add calculated columns to the input DataFrame based on existing data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The input DataFrame containing energy usage and production data.</span>
<span class="sd">    fillna : bool, optional</span>
<span class="sd">        Whether to fill missing values with 0 before performing calculations.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        The modified DataFrame with additional calculated columns.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function assumes that the input DataFrame contains the necessary</span>
<span class="sd">      columns such as &#39;ElektriciteitTerugleveringLaagDiff&#39;,</span>
<span class="sd">      &#39;ElektriciteitTerugleveringHoogDiff&#39;, &#39;ElektriciteitNetgebruikLaagDiff&#39;,</span>
<span class="sd">      &#39;ElektriciteitNetgebruikHoogDiff&#39;, &#39;ElektriciteitsgebruikWarmtepompDiff&#39;,</span>
<span class="sd">      &#39;ElektriciteitsgebruikBoosterDiff&#39;, &#39;ElektriciteitsgebruikBoilervatDiff&#39;,</span>
<span class="sd">      &#39;ElektriciteitsgebruikWTWDiff&#39;, &#39;ElektriciteitsgebruikRadiatorDiff&#39;,</span>
<span class="sd">      and &#39;Zon-opwekTotaalDiff&#39;.</span>
<span class="sd">    - The function assumes that missing values can be treated a 0s, typically after</span>
<span class="sd">      data cleaning and imputation.</span>
<span class="sd">    - The function fills missing values in each column with 0 before performing</span>
<span class="sd">      calculations to ensure that the operations do not fail due to missing data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">fillna</span><span class="p">:</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating TerugleveringTotaalNetto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;TerugleveringTotaalNetto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitTerugleveringLaagDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitTerugleveringHoogDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitNetgebruikLaagDiff&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitNetgebruikHoogDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Netuitwisseling&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Netuitwisseling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;TerugleveringTotaalNetto&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitsgebruikWarmtepompDiff&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikBoosterDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikBoilervatDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikWTWDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikRadiatorDiff&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Renaming Zon-opwekTotaalDiff to ZonopwekBruto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Zon-opwekTotaalDiff&quot;</span><span class="p">:</span> <span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalHuishoudelijk&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalHuishoudelijk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Netuitwisseling&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Zelfgebruik&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Zelfgebruik&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;TerugleveringTotaalNetto&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalBruto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalBruto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Zelfgebruik&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating TerugleveringTotaalNetto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;TerugleveringTotaalNetto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitTerugleveringLaagDiff&quot;</span><span class="p">]</span>
        <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitTerugleveringHoogDiff&quot;</span><span class="p">]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitNetgebruikLaagDiff&quot;</span>
        <span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitNetgebruikHoogDiff&quot;</span><span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Netuitwisseling&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Netuitwisseling&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;TerugleveringTotaalNetto&quot;</span>
        <span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitsgebruikWarmtepompDiff&quot;</span>
        <span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikBoosterDiff&quot;</span><span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalWarmtepomp&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikBoilervatDiff&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikWTWDiff&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikRadiatorDiff&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Renaming Zon-opwekTotaalDiff to ZonopwekBruto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Zon-opwekTotaalDiff&quot;</span><span class="p">:</span> <span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalHuishoudelijk&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalHuishoudelijk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Netuitwisseling&quot;</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalGebouwgebonden&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Zelfgebruik&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Zelfgebruik&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ZonopwekBruto&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;TerugleveringTotaalNetto&quot;</span>
        <span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating ElektriciteitsgebruikTotaalBruto&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;ElektriciteitsgebruikTotaalBruto&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span>
        <span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Zelfgebruik&quot;</span><span class="p">]</span>


    <span class="k">return</span> <span class="n">df</span></div>



<span class="c1"># This calculation is done on a df with resampled data - it results in net_impact</span>
<span class="c1"># Average of &#39;ElektriciteitsgebruikTotaalNetto&#39; and</span>
<span class="c1"># Average of &#39;ElektriciteitsgebruikTotaalWarmtepomp&#39; as</span>
<span class="c1"># a proxy for the the coldest two weeks</span>
<span class="c1"># Average &#39;ZonopwekBruto&#39; for the sunniest one week (days = 7)</span>
<span class="c1"># This is a rolling average so does not handle the edges of the year perfectly</span>
<div class="viewcode-block" id="add_rolling_avg">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.add_rolling_avg">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_rolling_avg</span><span class="p">(</span>
    <span class="n">group</span><span class="p">,</span>
    <span class="n">var</span><span class="o">=</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">,</span>
    <span class="n">days</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
    <span class="n">avg_var</span><span class="o">=</span><span class="s2">&quot;RollingAverage&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a rolling average column to each group in the DataFrame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : pd.DataFrame</span>
<span class="sd">        The DataFrame group on which to perform the operation.</span>
<span class="sd">        This should be a subset of a larger DataFrame that has been grouped by some key,</span>
<span class="sd">        for example, `df.groupby(&#39;some_column&#39;).apply(add_rolling_avg)`.</span>
<span class="sd">    var : str, optional</span>
<span class="sd">        The name of the column in &#39;group&#39; for which the rolling average will be calculated.</span>
<span class="sd">        Default is &#39;ElektriciteitsgebruikTotaalNetto&#39;.</span>
<span class="sd">    days : int, optional</span>
<span class="sd">        The number of days over which to calculate the rolling average.</span>
<span class="sd">        Default is 14 days.</span>
<span class="sd">    avg_var : str, optional</span>
<span class="sd">        The name of the new column in &#39;group&#39; that will store the calculated rolling average values.</span>
<span class="sd">        Default is &#39;RollingAverage&#39;.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with an additional column containing the rolling averages.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function assumes that the &#39;ReadingDate&#39; column exists in the input DataFrame and</span>
<span class="sd">      is sorted in ascending order. The &#39;ReadingDate&#39; column should be of datetime type.</span>
<span class="sd">    - The function calculates a rolling average using a window size determined by the number of days</span>
<span class="sd">      specified and the frequency of the data points in the group. It uses a forward-looking window,</span>
<span class="sd">      meaning that for each date, it computes the average of the next `days` worth of data points.</span>
<span class="sd">    - To handle cases where there are missing dates or irregular sampling intervals, the function</span>
<span class="sd">      first calculates the time difference between consecutive readings to determine how many timesteps</span>
<span class="sd">      correspond to the specified number of days. It then uses this calculated window size for the</span>
<span class="sd">      rolling average computation.</span>
<span class="sd">    - The `min_periods` parameter in the rolling method is set to half of the window size,</span>
<span class="sd">      ensuring that partial windows at the beginning and end of the group are still computed if they have</span>
<span class="sd">      sufficient data points.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">)</span>

    <span class="n">timedelta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">needed_timesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">timedelta</span><span class="p">)</span>

    <span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">needed_timesteps</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">needed_timesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">group</span></div>



<span class="c1"># Define the get_highest_avg_period function</span>
<div class="viewcode-block" id="get_highest_avg_period">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.get_highest_avg_period">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_highest_avg_period</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">avg_var</span><span class="o">=</span><span class="s2">&quot;RollingAverage&quot;</span><span class="p">,</span> <span class="n">days</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the start time, end time, and highest rolling average for each group in the DataFrame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : pd.DataFrame</span>
<span class="sd">        The DataFrame group on which to perform the operation.</span>
<span class="sd">        This should be a subset of a larger DataFrame that has been grouped by some key,</span>
<span class="sd">        for example, `df.groupby(&#39;some_column&#39;).apply(get_highest_avg_period)`.</span>
<span class="sd">    avg_var : str, optional</span>
<span class="sd">        The name of the column in &#39;group&#39; containing the rolling averages.</span>
<span class="sd">        Default is &#39;RollingAverage&#39;.</span>
<span class="sd">    days : int, optional</span>
<span class="sd">        The number of days over which the rolling average was calculated.</span>
<span class="sd">        Default is 14 days.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with columns for each group variable (if applicable), start time,</span>
<span class="sd">        end time, and highest rolling average.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function assumes that the &#39;ReadingDate&#39; column exists in the input DataFrame and</span>
<span class="sd">      is sorted in ascending order. The &#39;ReadingDate&#39; column should be of datetime type.</span>
<span class="sd">    - The function identifies rows with the highest value in the `avg_var` column and calculates</span>
<span class="sd">      the corresponding start and end times based on the number of days specified.</span>
<span class="sd">    - To handle cases where there are missing dates or irregular sampling intervals, the function</span>
<span class="sd">      first calculates the time difference between consecutive readings to determine how many timesteps</span>
<span class="sd">      correspond to the specified number of days. It then uses this calculated window size for</span>
<span class="sd">      determining the start and end times.</span>
<span class="sd">    - If the calculated start index is out of bounds (greater than or equal to the length of the group),</span>
<span class="sd">      it sets the start index to the last valid index in the group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">highest_rolling_avg</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">highest_rolling_avg_rows</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span> <span class="o">==</span> <span class="n">highest_rolling_avg</span><span class="p">]</span>

    <span class="n">timedelta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">needed_timesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">timedelta</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">highest_rolling_avg_rows</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="c1"># start_time = group.loc[idx, &#39;ReadingDate&#39;]</span>
        <span class="c1"># end_time_index = group.index.get_loc(idx) + needed_timesteps - 1</span>

        <span class="c1"># if end_time_index &gt;= len(group):</span>
        <span class="c1">#    end_time_index = len(group) - 1</span>

        <span class="c1"># end_time = group.iloc[end_time_index][&#39;ReadingDate&#39;]</span>

        <span class="n">end_time</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span>
        <span class="n">start_time_index</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">needed_timesteps</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">start_time_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">start_time_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_time_index</span><span class="p">][</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span>
        <span class="c1"># MJW: changed start time to end time and worked back from there. The rolling average was looking backwards, so the plot also needs to do that.</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;StartTime&quot;</span><span class="p">:</span> <span class="n">start_time</span><span class="p">,</span>
            <span class="s2">&quot;EndTime&quot;</span><span class="p">:</span> <span class="n">end_time</span><span class="p">,</span>
            <span class="s2">&quot;HighestRollingAverage&quot;</span><span class="p">:</span> <span class="n">highest_rolling_avg</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Extract the group variable name and value</span>
        <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_var_name</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
            <span class="n">result</span><span class="p">[</span><span class="n">group_var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<div class="viewcode-block" id="gelijktijdigheid">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.gelijktijdigheid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gelijktijdigheid</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df_5min</span><span class="p">,</span> <span class="n">rolling_average</span><span class="o">=</span><span class="s2">&quot;RollingAverage&quot;</span><span class="p">,</span> <span class="n">group_var</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the ratio of the highest rolling average of the given rolling average column between daily and 5-minute interval data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The input daily DataFrame containing the data.</span>
<span class="sd">    df_5min : pd.DataFrame</span>
<span class="sd">        The input 5-minute interval DataFrame containing the data.</span>
<span class="sd">    rolling_average : str, optional</span>
<span class="sd">        The column name of the rolling average. Default is &quot;RollingAverage&quot;.</span>
<span class="sd">    group_var : str, optional</span>
<span class="sd">        The column name to group by. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with the group variable (if applicable) and the ratio of the highest rolling average value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">highest_avg</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">group</span><span class="p">[</span><span class="n">rolling_average</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">group_var</span><span class="p">:</span>
        <span class="n">daily_max</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_var</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">highest_avg</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;HighestDailyAvg&quot;</span><span class="p">)</span>
        <span class="n">min_max</span> <span class="o">=</span> <span class="n">df_5min</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">group_var</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">highest_avg</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Highest5MinAvg&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">daily_max</span><span class="p">,</span> <span class="n">min_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;Ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;HighestDailyAvg&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;Highest5MinAvg&quot;</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">highest_daily_avg</span> <span class="o">=</span> <span class="n">highest_avg</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">highest_5min_avg</span> <span class="o">=</span> <span class="n">highest_avg</span><span class="p">(</span><span class="n">df_5min</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;HighestDailyAvg&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">highest_daily_avg</span><span class="p">],</span>
                <span class="s2">&quot;Highest5MinAvg&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">highest_5min_avg</span><span class="p">],</span>
                <span class="s2">&quot;Ratio&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">highest_daily_avg</span> <span class="o">/</span> <span class="n">highest_5min_avg</span><span class="p">],</span>
            <span class="p">},</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="get_lowest_avg_period">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.get_lowest_avg_period">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_lowest_avg_period</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">avg_var</span><span class="o">=</span><span class="s2">&quot;RollingAvg_Temperatuur&quot;</span><span class="p">,</span> <span class="n">days</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the start time, end time, and lowest rolling average for each group in the DataFrame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : pd.DataFrame</span>
<span class="sd">        The DataFrame group on which to perform the operation.</span>
<span class="sd">        This should be a subset of a larger DataFrame that has been grouped by some key,</span>
<span class="sd">        for example, `df.groupby(&#39;some_column&#39;).apply(get_lowest_avg_period)`.</span>
<span class="sd">    avg_var : str, optional</span>
<span class="sd">        The name of the column in &#39;group&#39; containing the rolling averages.</span>
<span class="sd">        Default is &#39;RollingAvg_Temperatuur&#39;.</span>
<span class="sd">    days : int, optional</span>
<span class="sd">        The number of days over which the rolling average was calculated.</span>
<span class="sd">        Default is 14 days.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with columns for each group variable (if applicable), start time,</span>
<span class="sd">        end time, and lowest rolling average.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function assumes that the &#39;ReadingDate&#39; column exists in the input DataFrame and</span>
<span class="sd">      is sorted in ascending order. The &#39;ReadingDate&#39; column should be of datetime type.</span>
<span class="sd">    - The function identifies rows with the lowest value in the `avg_var` column and calculates</span>
<span class="sd">      the corresponding start and end times based on the number of days specified.</span>
<span class="sd">    - To handle cases where there are missing dates or irregular sampling intervals, the function</span>
<span class="sd">      first calculates the time difference between consecutive readings to determine how many timesteps</span>
<span class="sd">      correspond to the specified number of days. It then uses this calculated window size for</span>
<span class="sd">      determining the start and end times.</span>
<span class="sd">    - If the calculated start index is out of bounds (greater than or equal to the length of the group),</span>
<span class="sd">      it sets the start index to the last valid index in the group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">lowest_rolling_avg</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">lowest_rolling_avg_rows</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span> <span class="o">==</span> <span class="n">lowest_rolling_avg</span><span class="p">]</span>

    <span class="n">timedelta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">needed_timesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">timedelta</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">lowest_rolling_avg_rows</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="c1"># start_time = group.loc[idx, &#39;ReadingDate&#39;]</span>
        <span class="c1"># end_time_index = group.index.get_loc(idx) + needed_timesteps - 1</span>

        <span class="c1"># if end_time_index &gt;= len(group):</span>
        <span class="c1">#    end_time_index = len(group) - 1</span>

        <span class="c1"># end_time = group.iloc[end_time_index][&#39;ReadingDate&#39;]</span>

        <span class="n">end_time</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span>
        <span class="n">start_time_index</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">needed_timesteps</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">start_time_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">start_time_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_time_index</span><span class="p">][</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span>
        <span class="c1"># MJW: changed start time to end time and worked back from there. The rolling average was looking backwards, so the plot also needs to do that.</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;StartTime&quot;</span><span class="p">:</span> <span class="n">start_time</span><span class="p">,</span>
            <span class="s2">&quot;EndTime&quot;</span><span class="p">:</span> <span class="n">end_time</span><span class="p">,</span>
            <span class="s2">&quot;LowestRollingAverage&quot;</span><span class="p">:</span> <span class="n">lowest_rolling_avg</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Extract the group variable name and value</span>
        <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;Group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_var_name</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
            <span class="n">result</span><span class="p">[</span><span class="n">group_var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<span class="c1"># Find the start and end of the coldest two-week period for each KNMI station</span>
<div class="viewcode-block" id="mark_coldest_two_weeks">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.mark_coldest_two_weeks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mark_coldest_two_weeks</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">avg_var</span><span class="o">=</span><span class="s2">&quot;TemperatuurRA&quot;</span><span class="p">,</span> <span class="n">days</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marks the coldest two-week period for each group in the DataFrame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : pd.DataFrame</span>
<span class="sd">        The DataFrame group.</span>
<span class="sd">    avg_var : str</span>
<span class="sd">        The variable containing the rolling averages.</span>
<span class="sd">    days : int</span>
<span class="sd">        The number of days over which the rolling average was calculated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.Series</span>
<span class="sd">        A boolean Series indicating whether each row is within the coldest two-week period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_index</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;YYYYMMDD&quot;</span><span class="p">,</span> <span class="s2">&quot;HH&quot;</span><span class="p">])</span>

    <span class="n">coldest_period</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">lowest_rolling_avg</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">lowest_rolling_avg_rows</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">avg_var</span><span class="p">]</span> <span class="o">==</span> <span class="n">lowest_rolling_avg</span><span class="p">]</span>

    <span class="n">needed_timesteps</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="n">days</span>

    <span class="c1"># Rolling average looks backwards, so the plot also needs to do that.</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">lowest_rolling_avg_rows</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">needed_timesteps</span>

        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="n">coldest_period</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">coldest_period</span> <span class="o">=</span> <span class="n">coldest_period</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">original_index</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coldest_period</span></div>


<span class="c1"># Find the start and end of the one week period with the highest peak for each project</span>
<div class="viewcode-block" id="mark_highest_peak">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.mark_highest_peak">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mark_highest_peak</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="s2">&quot;ElektriciteitsgebruikTotaalNetto&quot;</span><span class="p">,</span> <span class="n">days</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marks the one-week period for each group in the DataFrame around the highest peak.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group : pd.DataFrame</span>
<span class="sd">        The DataFrame group.</span>
<span class="sd">    var : str</span>
<span class="sd">        The variable containing the peak energy use.</span>
<span class="sd">    days : int</span>
<span class="sd">        The number of days to include.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.Series</span>
<span class="sd">        A boolean Series indicating whether each row is within the one-week period around the highest peak.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_index</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span>

    <span class="n">group</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">])</span>

    <span class="n">peak_period</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">highest_peak</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">highest_peak_rows</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">==</span> <span class="n">highest_peak</span><span class="p">]</span>

    <span class="n">timedelta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
    <span class="n">needed_timesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">timedelta</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">highest_peak_rows</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">needed_timesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="n">needed_timesteps</span>

        <span class="k">if</span> <span class="n">end_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

        <span class="n">peak_period</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">peak_period</span> <span class="o">=</span> <span class="n">peak_period</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">original_index</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">peak_period</span></div>



<div class="viewcode-block" id="switch_multiplier">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.switch_multiplier">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">switch_multiplier</span><span class="p">(</span><span class="n">interval_choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the multiplier for the switches in the calculation of the calculated columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interval_choice : str</span>
<span class="sd">        The interval over which the data is aggregated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The multiplier to use in unit conversions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">interval_choice</span> <span class="o">==</span> <span class="s2">&quot;5min&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">12</span>
    <span class="k">elif</span> <span class="n">interval_choice</span> <span class="o">==</span> <span class="s2">&quot;15min&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">4</span>
    <span class="k">elif</span> <span class="n">interval_choice</span> <span class="o">==</span> <span class="s2">&quot;60min&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">interval_choice</span> <span class="o">==</span> <span class="s2">&quot;6h&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">6</span>
    <span class="k">elif</span> <span class="n">interval_choice</span> <span class="o">==</span> <span class="s2">&quot;24h&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">24</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown interval&quot;</span><span class="p">)</span></div>


<span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;5min&quot;</span><span class="p">,</span> <span class="s2">&quot;15min&quot;</span><span class="p">,</span> <span class="s2">&quot;60min&quot;</span><span class="p">,</span> <span class="s2">&quot;24h&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="add_normalized_datetime">
<a class="viewcode-back" href="../../source/etdtransform.html#etdtransform.calculated_columns.add_normalized_datetime">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_normalized_datetime</span><span class="p">(</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">reference_date</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s2">&quot;2023-01-02&quot;</span><span class="p">),</span>
    <span class="n">datetime_column</span><span class="o">=</span><span class="s2">&quot;ReadingDate&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a normalized datetime column to the DataFrame or Ibis Table.</span>
<span class="sd">    Used to do analyses that depend on the time of day rather than date.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : pd.DataFrame or ibis.expr.types.TableExpr</span>
<span class="sd">        The DataFrame or Table.</span>
<span class="sd">    reference_date : datetime.datetime, optional</span>
<span class="sd">        The date used as reference for the normalization. Default is &#39;2023-01-02&#39;.</span>
<span class="sd">    datetime_column : str, optional</span>
<span class="sd">        The name of the column containing the datetime. Default is &#39;ReadingDate&#39;.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or ibis.expr.types.TableExpr</span>
<span class="sd">        The DataFrame or Table with a new column &#39;normalized_datetime&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time_of_day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">time</span>
        <span class="n">x</span><span class="p">[</span><span class="s2">&quot;day_of_week&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span>  <span class="c1"># Monday=0, Sunday=6</span>

        <span class="n">x</span><span class="p">[</span><span class="s2">&quot;normalized_datetime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;time_of_day&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">reference_date</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">t</span><span class="p">),</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;day_of_week&quot;</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ibis</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Expr</span><span class="p">):</span>
        <span class="c1"># Ibis logic</span>
        <span class="n">reference_date_literal</span> <span class="o">=</span> <span class="n">ibis</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">reference_date</span><span class="p">)</span>

        <span class="c1"># Extract time of day and day of week</span>
        <span class="n">time_of_day</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">day_of_week</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span><span class="o">.</span><span class="n">day_of_week</span><span class="o">.</span><span class="n">index</span><span class="p">()</span>

        <span class="n">combined_date</span> <span class="o">=</span> <span class="n">reference_date_literal</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">day_of_week</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">ibis</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">time_of_day_to_add</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">datetime_column</span><span class="p">]</span><span class="o">.</span><span class="n">date</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
            <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">normalized_datetime</span> <span class="o">=</span> <span class="n">combined_date</span> <span class="o">+</span> <span class="n">time_of_day_to_add</span>

        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span>
            <span class="n">time_of_day</span><span class="o">=</span><span class="n">time_of_day</span><span class="p">,</span>
            <span class="n">day_of_week</span><span class="o">=</span><span class="n">day_of_week</span><span class="p">,</span>
            <span class="n">normalized_datetime</span><span class="o">=</span><span class="n">normalized_datetime</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be either a pandas DataFrame or an Ibis TableExpr&quot;</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Nicolas Dickinson, Marten Witkamp, Petra Izeboud.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>